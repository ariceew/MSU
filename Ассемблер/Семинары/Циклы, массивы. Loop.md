Связи: [[_Навигатор Ассемблер]]
Теги: #Ассемблер #Семинар 

`loop <метка>` - зависит от регистра `cx` или `ecx`. До тех пор, пока `cx` не равен 0. 

Сначала уменьшает регистр на 1, а потом уже его проверяет

Сама уменьшает на 1 `cx`. Команда с постусловием. 

`jcxz Exit` - команда перехода, если `cx` равен 0, переходит в `Exit`. Команда страховка (в данном случае). 

Команда короткого перехода. 

Тело цикла - все команды между меткой и 


```
Be
```

`loope <метка>`. Тоже ее работа зависит от регистра `cx`. Плюс к этому, он смотрит на флаг `zf` (zero flag). Работает когда cx не равен нулю и когда zf не поднят. (полезно, когда мы ищем какое-то число в последовательности, которое не равно какому-то)

`cmp <регистр> <значение>` - команда сравнения. Сравнивает регистр с регистром, регистр с памятью, память с регистром, но не память с памятью. 

`cbw ` (convert byte to word), для того, чтобы деление работало правильно.

Когда мы делим на однобайтовое, частное помещаем в `al`, остаток в `ah`. 


`esi` - хранение индексов
для индекста использовать ячейку памяти

`loopne` - такая же команда, но работает, когда `zf` равен 0, а `cx` не равен нулю. Когда хотим найти какой-то элемент, который равен какому-то.

Пример реализации:


```
%include "io.inc"
section .bss
b resw 1
section .data
a dw 1
i db 0
arr db 5, 3, 1, 2, 1
section .text
global CMAIN
CMAIN:

    mov ebp, esp
    xor eax, eax
    xor ecx, ecx
    xor ebx, ebx
    mov cx, 3
    jcxz Exit
Begin:

    inc word [a] ; inc [a]
    loop Begin ; Цикл, который работает за счет вызова функции в которой сам же находится
Exit:

    mov ax, [a]
    mov [b], ax
    mov cx, 5
    mov ax, 13
    mov bl, 2
    jcxz Exit1 ; ???
Begin1:

    div bl
    PRINT_DEC 1, al
    cmp ah, 1 ; делить, до тех пор, пока остаток не станет 1
    cbw ; convert byte to word увеличивает размер выделенный под переменную
    loope Begin1 

Exit1:

    mov cx, 5
    jcxz Exit2
    mov esi, 0
    mov edi, 0
Begin2:

    mov al, [arr + edi + esi]
    inc esi
    cmp al, 2
    loopne Begin2 
Exit2:

    PRINT_CHAR 0x0A
    PRINT_DEC 4, esi
    ret
```
