Связи: [[_Навигатор Ассемблер]]
Теги: #Ассемблер #Семинар 
(13 лекция)
# Содержание:
- [[#Команды стека]]
- [[#Процедуры]]


Память автоматическая. Не нужно удалять. 

[[Регистры#^bf5399 | Регистр ESP]]
[[Регистры#^1b2f74 | Регистр EBP]] - база
У каждого процесса свой стек. 
## Алгоритмы

Самый большой адрес на дне стека
Когда что-то кладете в стек, адреса уменьшаются
Изменение в этом регистре происходит автоматически.
Дно стека постоянно



# Команды стека
`push <операнд>` - операндом может быть регистр, ячейка памяти или константа. (источник)

может работать только с двумя байтами или четырьмя байтами.
Если надо закинуть 1 байт, нужно "обмануть"

`pop <операнд>` куда кладется. (приемник)

может работать только с двумя байтами или четырьмя байтами.
Если надо закинуть 1 байт, нужно "обмануть"


Полезно перед вызовом процедур записывать значения из регистров в стек

## pusha/pushad 
Команда PUSHA сохраняет в стеке содержимое регистров AX, CX, DX, BX, SP, BP, SI, DI 
/
Команда PUSHAD сохраняет в стеке содержимое регистров EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.

## popa / popad
Эти команды восстанавливают из стека значения регистров (E)DI, (E)SI, (E)BP, (E)SP, (E)BX, (E)DX, (E)CX, (E)AX. Содержимое регистра (E)SP не восстанавливается из стека, а изменяется как обычно.

## pushhf / pushhfd
Команда PUSHF сохраняет в стеке младшие 16 бит регистра флагов. Команда PUSHFD сохраняет в стеке все 32 бита регистра флагов.

## popf / popfd
Команда POPF восстанавливает из стека младшие 16 бит регистра флагов. Команда POPFD восстанавливает из стека все 32 бита регистра флагов.


> Если в Sasm писать push, он все равно сохранит все 32


Код:


```
section .data
a dd 100
b dd 10

section .text
global _start_:
_start_ ;
xor eax, eax
xor ecx, ecx
mov eax, [a]
mov ecx, [b]
PRINT_DEC 4, eax
PRINT_CHAR ' '
PRINT_DEC 4, ecx
NEWLINE
PRINT_DEC 4, esp
push eax
push ecx
PRINT_DEC 4, esp
NEWLINE ; программа завершится аварийно
ret
pop eax
pop ecx 
PRINT_DEC 4, eax
NEWLINE
PRINT_DEC 4, ecx ; значение поменяется из за структуры стека
pushad
PRINT_DEC 4,esp
NEWLINE
popad
NEWLINE
label1:
PRINT_STRING "Hello"
cmp eax, ecx
pushf
NEWLINE
PRINT_DEC 4, esp
cmp dword [a], 100
popfd 
jne label1 ; Аварийное завершение (без popfd), с popfd - бесконечный цикл

```

# Почему программа завешится аварийно?

ОС положила в стек сначала адрес возврата, а потом уже то, что мы кладем в стек
команда ret это выход из процедуры. Она думает, что на вершине стека лежит адрес возврата. -> аварийное завершение программы.

Поэтому надо использовать в паре с `push` еще и `pop`. 


# Процедуры
Это метка
Какие то команды
ret

Если процедуру разместим внутри вызывающей процедуры, и даже если мы не будем ее вызывать, она все равно один раз вызовется. 

Надо распологать процедуру после мейна

Командой jump прыгнуть на метку

Проблема вернуться из процедуры.

Нужно обеспечить адресс возврата

Прежде чем вызвать процедуру, кладем адресс возврата, но это неудобно.

Поэтому придумали команды `call` и `ret`

`call <название процедуры>` 

После мейна ret, нужно там узказать тело процедуры.

Что он делает?
1. Кладется в стек адрес возврата
2. Если указать просто команду ret, она берет первые 4 байта из стека, если мы все хорошо прописали, то он возьмет адрес возврата, если нет, будет аварийное завершение. 

> Вывод: Если мы кладем что-то в стек, то надо позаботиться, чтобы взять это из стека

> Другое решение `ret m` - увеличивает значение. Например:


```
func:
push eax
push ebx

ret 8
```

## Как передавать переменные в процедуры?

Можно записать их в стек
![[IMG_1883 2.jpg]]
В процедуре будет такая картина. чтобы не потерять адрес возврата, мы можем сделать так:


```
push dword, [a]
push dword [b]

call SUM
mov eax, [a]
...
ret

SUM:
mov eax, [ESP + 4]
mov ebx, [ESP + 8]
add eax, ebx
ret
```

возвращаемый результат хранится обычно в `eax`. 

как вернуть значение?

`lea` - возвращает [[эффективный аддрес]] 



```
section .data
a dd 100
b dd 10

section .text
global _start_:
_start_ :
xor eax, eax
xor ebx, ebx
push dword [a]
push dword [b]
PRINT_STRING "In main"
NEWLINE
PRINT_DEC 4, [a]
PRINT_CHAR ' '
PRINT_DEC 4, [b]
NEWLINE
call SQUARE
PRINT_STRING "In main"
NEWLINE
PRINT_DEC 4, [a]
PRINT_CHAR ' '
PRINT_DEC 4, [b]
NEWLINE
ret 


SQUARE:
NEWLINE
PRINT_STRING "In square"
NEWLINE
mov eax, [ESP + 8]
mul eax
PRINT_DEC eax
PRINT_CHAR ' '
mov eax, [ESP + 4]
mul eax ; первое значение потеряется
PRINT_DEC [ESP + 4]
ret 8
```

!!! в любом языке программирования если у нас есть 

```
sum (int a, int b) - сначала в стек кладется b, потом уже a
```

ДЗ
написать процедуру передается два числа
большее из чисел возводим в квадрат